---
title: "Small RNA Seq - Course Data"
author: "Anton Enright & Steph Wenlock"
date: \'`r format(Sys.time(), '%d %B, %Y')`\'
always_allow_html: yes
output:
  github_document:
    toc: true
---


```{r setup, results='hide',message=F, warning=F, echo=F}
require(knitr)
opts_knit$set(root.dir = '~/Desktop/course_data/smallrna_participants/')
opts_chunk$set(dev="png", 
               dev.args=list(type="cairo"),
               comment='           ##',
               dpi=300)

```

# Analysis of smallRNA Seq datasets

In this practical we will be taking the 12 samples you generated libraries for on the course.
We will trim off the 3' Sequencing adapters and then you will construct a protocol for their analysis

The fastq files, pdata file and mircounts file are now installed on your desktops.

## Experimental Design
This is the sample description file used for the analyses below.

```{r}
setwd("~/Desktop/course_data/smallrna_participants/")
pdata <- read.table("pdata.txt",header=TRUE,check.names=FALSE)
kable(pdata)
```

## Setup
Lets load some libraries to get started
```{r,message=FALSE,warning=FALSE}
library(Reaper)
library(gplots)
library(RColorBrewer)
library(DESeq2)
library(reshape2)
library(ggplot2)
```

Hopefully, you will see a compressed FASTQ txt file for each of the 12 lanes

It is important that we also load information for reaper that tells it the following:

*   Which FASTQ files are present.
*   Which Barcode sequences correspond to which sample names.
*   What 5' and 3' sequencing adapters were used in library generation.

Next we will start the Reaper algorithm. It will perform the following functions on all the lanes we have provided:

*   Splitting up reads according to provided barcodes
*   Detection of 3' or 5' adapter contamination using Smith-Waterman local alignment
*   Detection of low-complexity sequences, such as Poly-As or Poly-Ns
*   Quality score thresholding and trimming if required
*   Collapsing of reads according to depth in a summary FASTA result file per barcode per lane.
*   Generation of Quality Control plots for assessing sequencing quality

Reaper is started by passing it our samples table and telling it which "mode" to run in, in this case the mode is set to: **no-bc**.

```{r}
reaper(pdata,"no-bc");
```

Reaper is designed to be fast and memory-efficient so it should run on any machine with 500MB of RAM or more. The time taken to complete the run depends on how fast the processors in your machine are.

Let's take a look at the Quality Control Metrics generated

```{r}
reaperQC(pdata)
```

## SmallRNA Read Quality Control

Lets also make a nice PDF of the results and explore the QC metrics for the data
 
```{r}
pdf("reaper.pdf",width=12)
reaperQC(pdata)
dev.off()
```

You should get one plot back for each lane processed.

## Mapping Cleaned Reads to MicroRNAs

This has been done for you, just like shown in the previous practical. The results are stored in a file called mircounts.txt.

# Analysis of the smallRNA count data

## Experiment Setup

All data were pre-processed using *minion* to identify and check adapters, *reaper* to trim adapter sequences followed by *tally* to deduplicate reads while maintaining depth information. Subsequent to this all reads passed through mapping against all miRBase (Release 22) precursor sequences for Mouse. Reads were summed across paired end sequences for the same read pair. Finally reads are loaded into R for final analysis.

For this analysis, we will get you started with some basic setup for DESeq2.

## Preparation
Lets prepare some colour schemes for heatmaps and sample colours
```{r, results='hide',message=F, warning=F}

hmcol = colorRampPalette(brewer.pal(9, "GnBu"))(100)
spectral <- colorRampPalette(rev(brewer.pal(11, "Spectral")), space="Lab")(100)

```

# Main Analysis

## Count Loading

We can now load all the count data
```{r}
mircounts <- read.table("mircounts.txt",header=TRUE,row.names=1)

```

Lets set up the count matrix column names and make a list of genotype conditions
```{r}
conds=as.factor(as.character(pdata$genotype))
conds
```

## Count Preparation & Normalisation
We are now ready to create a DESeq object from the counts table. 
```{r}

#Lets Load the Counts First
coldata = as.data.frame(t(t(conds)))
rownames(coldata)=colnames(mircounts)
colnames(coldata)='treatment'
dds <- DESeqDataSetFromMatrix(countData = mircounts, colData = coldata, design = ~ treatment)
```

We are  ready to normalise the data, but first we should look at the number of sequenced reads per sample. There are some stark differences across the samples.
```{r}
cond_colours = brewer.pal(2,"Set2")[conds]
names(cond_colours)=pdata$genotype

barplot(apply(mircounts,2,sum), las=2,col=cond_colours,main="Pre Normalised Counts",cex.names=0.4)
legend("topright",levels((conds)),cex=0.6,fill=cond_colours[levels(conds)])

```

## DESeq2 Data loading and normalisation

```{r}
dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds)
plotDispEsts(dds)

normcounts <- counts(dds, normalized=TRUE)
rawcounts=counts(dds,normalized=FALSE)
log2counts=log2(normcounts+1)


barplot(apply(normcounts,2,sum), las=2,col=cond_colours,main="Post-Normalised Counts",cex.names=0.4)
legend("topright",levels((conds)),cex=0.6,fill=cond_colours[levels(conds)])
```

# Completing the Analysis

You should continue to analyse the data using the previous practical as inspiration and copying and modifying code blocks.

We want to do the following

* Check the basic QC of the samples.
* This could be barplots, heatmaps, PCA or tSNE plots etc.
* Remove any samples that seem to be big outliers, remember to remove from both *mircounts* and *pdata* so that things are consistent.
* Once cleaned up, renormalise the samples with DESeq2 and replot your QC metrics to see the improvement.
* After this you probably want to run the same statistical test as last time, i.e. scr vs wt and create a statistical list of hits.
* Make a volcano plot and save your result table to a file.

# Removing bad samples
```{r}

#mircounts=mircounts[,c(1,2,3,4,5,6,9,11)]
#pdata=pdata[c(1,2,3,4,5,6,9,11),]
conds=as.factor(as.character(pdata$genotype))
cond_colours = brewer.pal(2,"Set2")[conds]
names(cond_colours)=pdata$genotype

coldata = as.data.frame(t(t(conds)))
rownames(coldata)=colnames(mircounts)
colnames(coldata)='treatment'
dds <- DESeqDataSetFromMatrix(countData = mircounts, colData = coldata, design = ~ treatment)
dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds)
plotDispEsts(dds)



normcounts <- counts(dds, normalized=TRUE)
rawcounts=counts(dds,normalized=FALSE)
log2counts=log2(normcounts+1)

```


```{r}
pca2=prcomp(t(normcounts),center=TRUE)

plot(pca2$x, col=cond_colours,  pch=19, cex=2, main="Sample to Sample PCA (VST)")
text(pca2$x, as.vector(colnames(mircounts)), pos=3, cex=0.4)

heatmap.2(cor(log2counts),trace="none",col=hmcol,main="Sample to Sample Correlation (Log2 Counts)",cexRow=0.5,cexCol=0.5,RowSideColors=cond_colours, margins=c(9,7))

library(Rtsne)
tsne <- Rtsne(t(normcounts), perplexity = 1, check_duplicates = FALSE)
tsne.df <- data.frame(tsne.1 = tsne$Y[,1], tsne.2 = tsne$Y[,2])

ggplot(data = tsne.df, aes(tsne.1, tsne.2)) + 
  geom_point(size = 6, pch = 20, colour = cond_colours) +
  geom_text(size = 2, vjust=2, aes(label=colnames(normcounts))) +
  scale_alpha_discrete(range = c(0.5, 1)) +
  theme_minimal() +
  ylab("tSNE 1") +
  xlab("tSNE 2") 
```

```{r}
top10=apply(mircounts,1,sum)[1:10]
top10[11]=sum(apply(mircounts,1,sum)[11:nrow(mircounts)])
names(top10)[11]="other"
pie(top10,col=brewer.pal(11,"Set3"),main="Top10 microRNAs")

barplot(t(log2counts[rownames(mircounts)[grep("mir-29[a-z]",rownames(mircounts))],]),beside=T,las=2,cex.names=0.5,col=cond_colours,main="miR-29 levels (VST)")
legend("topright",rownames(pdata),fill=cond_colours,cex=0.4)
```


```{r}
p_threshold=0.05
lfc_threshold=0.75

cds <- nbinomWaldTest(dds)

res=results(cds,contrast=c("treatment","wt","scr"))
res <- res[order(res$padj),]
res

sig = rownames(res[(abs(res$log2FoldChange) > lfc_threshold) & (res$padj < p_threshold) & !is.na(res$padj),])

plot(res$log2FoldChange,-log(res$padj,10),ylab="-log10(Adjusted P)",xlab="Log2 FoldChange",main=paste("Volcano Plot","WT v Scr"),pch=19,cex=0.4)      
points(res[sig,"log2FoldChange"],-log(res[sig,"padj"],10),pch=19,cex=0.4,col="red")
text(res[sig[1:10],"log2FoldChange"],-log(res[sig[1:10],"padj"],10),pch=19,cex=0.4,pos=2,labels = rownames(res[sig[1:10],]))

abline(h=-log10(p_threshold),lty=3)
abline(v=-lfc_threshold,lty=3)
abline(v=lfc_threshold,lty=3) 

write.table(cbind(as.matrix(counts(dds,normalized=T)[rownames(res),]),as.matrix(res)),"mouse_results.txt",quote=F,sep="\t")

```